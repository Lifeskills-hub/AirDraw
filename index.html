<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AirDraw - MediaPipe Hands (Fixed)</title>

  <!-- Updated MediaPipe Hands via TFJS - Official & Working -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@latest/dist/tf-core.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@latest/dist/tf-converter.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@latest/dist/tf-backend-webgl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>

  <style>
    body { margin:0; background:#000; overflow:hidden; font-family:sans-serif; touch-action:none; }
    #video { width:100vw; height:100vh; object-fit:cover; transform:scaleX(-1); } /* Mirror video */
    #canvas { position:fixed; top:0; left:0; width:100%; height:100%; transform:scaleX(-1); pointer-events:none; }
    #controls {
      position:fixed; bottom:30px; left:50%; transform:translateX(-50%);
      display:flex; gap:18px; z-index:10;
    }
    button {
      width:70px; height:70px; border-radius:50%; border:none; font-weight:bold; color:white; 
      box-shadow:0 4px 15px rgba(0,0,0,0.5); touch-action:manipulation;
      cursor:pointer;
    }
    #clear { background:#444; width:120px; border-radius:40px; }
    #status {
      position:fixed; top:20px; left:50%; transform:translateX(-50%);
      color:white; background:rgba(0,0,0,0.7); padding:10px 20px; border-radius:8px; z-index:10;
      font-size:16px;
    }
    #debug {
      position:fixed; top:80px; left:50%; transform:translateX(-50%);
      color:lime; background:rgba(0,0,0,0.7); padding:10px; border-radius:8px; z-index:10;
      font-size:14px; max-width:300px;
    }
  </style>
</head>
<body>

<video id="video" autoplay playsinline muted></video>
<canvas id="canvas"></canvas>
<div id="status">Loading MediaPipe Hands...</div>
<div id="debug">Debug info will appear here</div>

<div id="controls">
  <button style="background:#ffffff; color:#000">White</button>
  <button style="background:#ffff00; color:#000">Yellow</button>
  <button style="background:#ff0066">Pink</button>
  <button style="background:#00ffff">Cyan</button>
  <button style="background:#ff6600">Orange</button>
  <button id="clear">CLEAR</button>
</div>

<script>
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const status = document.getElementById('status');
  const debug = document.getElementById('debug');
  
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let detector;
  let currentColor = '#ffff00';
  let lastX = null, lastY = null;
  let isDrawing = false;

  // Index finger tip = landmark 8 (confirmed from docs)
  const FINGER_TIP_INDEX = 8;

  async function init() {
    status.textContent = "Loading model...";
    
    // Set WebGL backend
    await tf.setBackend('webgl');
    await tf.ready();

    const model = handPoseDetection.SupportedModels.MediaPipeHands;
    const detectorConfig = {
      runtime: 'mediapipe',  // Use MediaPipe runtime (more reliable)
      modelType: 'full',     // Better accuracy
      maxHands: 1,
      solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands',
    };

    try {
      detector = await handPoseDetection.createDetector(model, detectorConfig);
      status.textContent = "Model loaded! Starting camera...";
      console.log('Detector ready!');
      startCamera();
    } catch (err) {
      status.textContent = "Model failed: " + err.message;
      console.error(err);
    }
  }

  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { 
          facingMode: "user", 
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });
      video.srcObject = stream;
      
      video.onloadedmetadata = () => {
        video.play();
        status.textContent = "âœ… Draw with INDEX FINGER! Hold it steady in frame.";
        debug.textContent = "Camera ready. Show your hand!";
        requestAnimationFrame(detectHands);
      };
    } catch (err) {
      status.textContent = "Camera error: " + err.message;
    }
  }

  async function detectHands() {
    if (!detector || !video.videoWidth) {
      requestAnimationFrame(detectHands);
      return;
    }

    // Pass flipHorizontal: true to match mirrored video
    const hands = await detector.estimateHands(video, { flipHorizontal: true });

    // DON'T clear canvas - keep drawings! Only clear on button.
    // ctx.clearRect(0, 0, canvas.width, canvas.height);

    debug.textContent = `Hands detected: ${hands.length}`;

    if (hands.length > 0) {
      const keypoints = hands[0].keypoints;  // 2D keypoints in VIDEO pixel coords
      const tip = keypoints[FINGER_TIP_INDEX];

      // Map video pixels directly to canvas pixels (perfect match!)
      const x = tip.x;
      const y = tip.y;

      // Draw glowing fingertip cursor
      ctx.save();
      ctx.fillStyle = currentColor;
      ctx.shadowColor = currentColor;
      ctx.shadowBlur = 25;
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();

      // Draw smooth line trail
      if (isDrawing && lastX !== null && lastY !== null) {
        ctx.lineWidth = 18;
        ctx.lineCap = 'round';
        ctx.strokeStyle = currentColor;
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      lastX = x;
      lastY = y;
      isDrawing = true;

      debug.textContent = `Hands: ${hands.length} | Tip: (${Math.round(x)}, ${Math.round(y)})`;
    } else {
      isDrawing = false;
      lastX = null;
      lastY = null;
      debug.textContent = `Hands: ${hands.length} | Show your hand!`;
    }

    requestAnimationFrame(detectHands);
  }

  // FIXED: Color buttons with touch support
  document.querySelectorAll('#controls button:not(#clear)').forEach(btn => {
    // Mouse + Touch events
    const setColor = (e) => {
      e.preventDefault();
      currentColor = btn.style.backgroundColor;
      // Convert rgb to hex
      if (currentColor.startsWith('rgb')) {
        const rgb = currentColor.match(/\d+/g).map(Number);
        currentColor = '#' + rgb.map(n => n.toString(16).padStart(2, '0')).join('');
      }
      console.log('Color:', currentColor);
      status.textContent = `Color: ${currentColor} | Draw with INDEX finger!`;
    };
    
    btn.addEventListener('click', setColor);
    btn.addEventListener('touchend', setColor);
  });

  // Clear button
  document.getElementById('clear').addEventListener('click', () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    lastX = null; lastY = null; isDrawing = false;
  });
  document.getElementById('clear').addEventListener('touchend', (e) => {
    e.preventDefault();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    lastX = null; lastY = null; isDrawing = false;
  });

  // Resize handler
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });

  // Start app
  init().catch(err => {
    status.textContent = "Init error: " + err.message;
    console.error(err);
  });
</script>
</body>
</html>
