<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Air Draw: Hand Gesture Drawing Game with Flies</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <style>
    body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
    .container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    .input_video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    .output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .mirrored { transform: scaleX(-1); }
    .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
    button, select { padding: 10px 20px; font-size: 16px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; touch-action: manipulation; }
    button:hover, select:hover { background: #0056b3; }
    .instructions { position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; z-index: 10; }
  </style>
</head>
<body>
  <div class="container">
    <video class="input_video"></video>
    <canvas class="output_canvas"></canvas>
    <div class="instructions">
      <p>Instructions:</p>
      <ul>
        <li>Open hand: Draw with index finger (lines stay unless it's a closed circle).</li>
        <li>Pinch (thumb + index): Stop drawing and check for circle to catch flies.</li>
        <li>Draw closed circles around flies to eliminate them (circle will disappear).</li>
        <li>Change colors, flip camera, or toggle mirror as needed.</li>
      </ul>
    </div>
    <div class="controls">
      <button onclick="clearCanvas()">Clear Drawing</button>
      <button onclick="toggleCamera()">Flip Camera</button>
      <button onclick="toggleMirror()">Toggle Mirror</button>
      <select onchange="changeColor(this.value)">
        <option value="red">Red</option>
        <option value="blue">Blue</option>
        <option value="green">Green</option>
        <option value="black">Black</option>
      </select>
    </div>
  </div>
  <script type="module">
    const videoElement = document.querySelector('.input_video');
    const canvasElement = document.querySelector('.output_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    let currentFacing = 'user';
    let isMirrored = true; // Default to mirrored for natural feel
    let currentStream = null;
    let currentColor = 'red';
    let strokes = [];
    let currentStroke = { points: [], color: currentColor, width: 5 };
    let flies = [];
    let score = 0;

    function changeColor(color) {
      currentColor = color;
      currentStroke.color = currentColor; // Allow mid-stroke color change for flexibility
    }

    function clearCanvas() {
      strokes = [];
      currentStroke = { points: [], color: currentColor, width: 5 };
      score = 0;
      flies = [];
      for (let i = 0; i < 5; i++) addFly();
      redraw(); // Explicit redraw after clear
    }

    function redraw() {
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // Draw persistent strokes
      for (let stroke of strokes) {
        if (stroke.points.length < 2) continue;
        canvasCtx.beginPath();
        canvasCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length; i++) {
          canvasCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
        }
        canvasCtx.strokeStyle = stroke.color;
        canvasCtx.lineWidth = stroke.width;
        canvasCtx.stroke();
      }

      // Draw current stroke
      if (currentStroke.points.length >= 2) {
        canvasCtx.beginPath();
        canvasCtx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
        for (let i = 1; i < currentStroke.points.length; i++) {
          canvasCtx.lineTo(currentStroke.points[i].x, currentStroke.points[i].y);
        }
        canvasCtx.strokeStyle = currentStroke.color;
        canvasCtx.lineWidth = currentStroke.width;
        canvasCtx.stroke();
      }

      // Draw flies
      canvasCtx.font = '20px Arial';
      canvasCtx.fillStyle = 'black';
      for (let fly of flies) {
        canvasCtx.fillText('ðŸª°', fly.x, fly.y);
      }

      // Draw score
      canvasCtx.fillStyle = 'black';
      canvasCtx.font = '20px Arial';
      canvasCtx.fillText(`Score: ${score}`, 10, 30);
    }

    async function startCamera(facing) {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      const constraints = {
        video: {
          facingMode: facing,
          width: { ideal: window.innerWidth },
          height: { ideal: window.innerHeight }
        }
      };
      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        videoElement.srcObject = stream;
        videoElement.play();
        // Send frames in loop
        async function sendFrame() {
          if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
            await hands.send({ image: videoElement });
          }
          requestAnimationFrame(sendFrame);
        }
        sendFrame();
      } catch (err) {
        console.error('Error accessing camera:', err);
      }
    }

    function toggleCamera() {
      currentFacing = currentFacing === 'user' ? 'environment' : 'user';
      startCamera(currentFacing);
    }

    function toggleMirror() {
      isMirrored = !isMirrored;
      videoElement.classList.toggle('mirrored', isMirrored);
      canvasElement.classList.toggle('mirrored', isMirrored);
    }

    function addFly() {
      flies.push({
        x: Math.random() * canvasElement.width,
        y: Math.random() * canvasElement.height,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4
      });
    }

    function onResults(results) {
      // Resize canvas if needed
      if (canvasElement.width !== videoElement.videoWidth || canvasElement.height !== videoElement.videoHeight) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        // Re-add flies if resized
        flies = [];
        for (let i = 0; i < 5; i++) addFly();
      }

      let ix = null, iy = null, tx = null, ty = null, dist = 0;
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const indexTip = landmarks[8];
        const thumbTip = landmarks[4];

        ix = (isMirrored ? 1 - indexTip.x : indexTip.x) * canvasElement.width;
        iy = indexTip.y * canvasElement.height;
        tx = (isMirrored ? 1 - thumbTip.x : thumbTip.x) * canvasElement.width;
        ty = thumbTip.y * canvasElement.height;

        dist = Math.hypot(ix - tx, iy - ty) / canvasElement.width;

        if (dist > 0.05) { // Draw mode
          if (currentStroke.points.length === 0 || 
              Math.hypot(ix - currentStroke.points[currentStroke.points.length - 1].x, 
                         iy - currentStroke.points[currentStroke.points.length - 1].y) > 3) { // Min distance for smoother lines
            currentStroke.points.push({ x: ix, y: iy });
          }
        } else { // Pinch mode
          if (currentStroke.points.length > 10) {
            const first = currentStroke.points[0];
            const last = currentStroke.points[currentStroke.points.length - 1];
            const closeDist = Math.hypot(first.x - last.x, first.y - last.y);
            if (closeDist < 50) {
              const path = new Path2D();
              path.moveTo(first.x, first.y);
              for (let p of currentStroke.points.slice(1)) {
                path.lineTo(p.x, p.y);
              }
              path.closePath();
              let eliminated = 0;
              flies = flies.filter(fly => {
                if (canvasCtx.isPointInPath(path, fly.x, fly.y)) {
                  eliminated++;
                  return false;
                }
                return true;
              });
              score += eliminated;
              // Circle disappears
            } else {
              strokes.push(currentStroke);
            }
          }
          currentStroke = { points: [], color: currentColor, width: 5 };
        }
      }

      // Update flies positions
      for (let fly of flies) {
        fly.x += fly.vx;
        fly.y += fly.vy;
        if (fly.x < 0 || fly.x > canvasElement.width) fly.vx *= -1;
        if (fly.y < 0 || fly.y > canvasElement.height) fly.vy *= -1;
      }

      // Redraw everything
      redraw();

      // Visual feedback for finger tip
      if (ix !== null) {
        canvasCtx.beginPath();
        canvasCtx.arc(ix, iy, 10, 0, 2 * Math.PI);
        canvasCtx.fillStyle = dist > 0.05 ? 'green' : 'yellow';
        canvasCtx.fill();
      }
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6, // Slightly higher for better accuracy
      minTrackingConfidence: 0.6, // Slightly higher for smoother tracking
    });
    hands.onResults(onResults);

    // Initialize
    for (let i = 0; i < 5; i++) addFly();
    startCamera(currentFacing);
    videoElement.classList.toggle('mirrored', isMirrored);
    canvasElement.classList.toggle('mirrored', isMirrored);
  </script>
</body>
</html>
