<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>AirDraw Pro - Mirror Video + Correct Drawing</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>

  <style>
    body { margin:0; background:#000; overflow:hidden; touch-action:none; }
    #video { width:100vw; height:100vh; object-fit:cover; transform:scaleX(-1); } /* Mirror video (selfie style) */
    #canvas { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; } /* Canvas NOT mirrored */
    button { width:70px; height:70px; border-radius:50%; border:none; box-shadow:0 4px 20px rgba(0,0,0,0.6); font-weight:bold; color:white; }
    #controls { position:fixed; bottom:30px; left:50%; transform:translateX(-50%); display:flex; gap:18px; z-index:10; }
    #clear { background:#333; width:120px; border-radius:40px; }
    #status { position:fixed; top:20px; left:50%; transform:translateX(-50%); color:white; background:rgba(0,0,0,0.7); padding:10px 20px; border-radius:10px; z-index:10; }
  </style>
</head>
<body>
<video id="video" autoplay playsinline muted></video>
<canvas id="canvas"></canvas>
<div id="status">Loading AirDraw (mirror view + correct drawing)...</div>

<div id="controls">
  <button style="background:#fff;color:#000">White</button>
  <button style="background:#ffff00;color:#000">Yellow</button>
  <button style="background:#ff1493">Pink</button>
  <button style="background:#00ffff">Cyan</button>
  <button style="background:#ff6600">Orange</button>
  <button id="clear">CLEAR</button>
</div>

<script>
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const status = document.getElementById('status');
  canvas.width = innerWidth; canvas.height = innerHeight;

  let detector, currentColor = '#ffff00';
  let smoothX = 0, smoothY = 0;
  let lastDrawX = 0, lastDrawY = 0;
  const SMOOTHING = 0.65;
  const MIN_MOVE = 10;
  const TIP = 8; // index finger tip

  async function init() {
    await tf.setBackend('webgl');
    const model = handPoseDetection.SupportedModels.MediaPipeHands;
    detector = await handPoseDetection.createDetector(model, {
      runtime: 'mediapipe',
      modelType: 'full',
      maxHands: 1,
      solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands'
    });

    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:"user"}});
    video.srcObject = stream;
    video.onloadedmetadata = () => {
      video.play();
      status.textContent = "Perfect! Mirror view + correct drawing ready";
      requestAnimationFrame(loop);
    };
  }

  async function loop() {
    // Let MediaPipe see the UNMIRRORED video internally (so coordinates are natural)
    const hands = await detector.estimateHands(video, {flipHorizontal: false});

    if (hands.length > 0) {
      const tip = hands[0].keypoints[TIP];

      // Coordinates from MediaPipe are correct (not mirrored)
      // We draw them directly on the non-mirrored canvas â†’ perfect match!
      const x = tip.x;
      const y = tip.y;

      // Smooth
      smoothX = smoothX * SMOOTHING + x * (1 - SMOOTHING);
      smoothY = smoothY * SMOOTHING + y * (1 - SMOOTHING);

      // Glowing cursor
      ctx.fillStyle = currentColor;
      ctx.shadowColor = currentColor;
      ctx.shadowBlur = 30;
      ctx.beginPath();
      ctx.arc(smoothX, smoothY, 22, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Draw line
      if (Math.hypot(smoothX - lastDrawX, smoothY - lastDrawY) > MIN_MOVE) {
        ctx.lineWidth = 20;
        ctx.lineCap = ctx.lineJoin = 'round';
        ctx.strokeStyle = currentColor;
        ctx.beginPath();
        ctx.moveTo(lastDrawX, lastDrawY);
        ctx.lineTo(smoothX, smoothY);
        ctx.stroke();
        lastDrawX = smoothX;
        lastDrawY = smoothY;
      }
    } else {
      smoothX = smoothY = lastDrawX = lastDrawY = 0;
    }

    requestAnimationFrame(loop);
  }

  // Color buttons
  document.querySelectorAll('#controls button:not(#clear)').forEach(b => {
    b.onclick = b.ontouchend = (e) => {
      e.preventDefault();
      currentColor = getComputedStyle(b).backgroundColor;
      if (currentColor.startsWith('rgb')) {
        const [r,g,b] = currentColor.match(/\d+/g);
        currentColor = '#' + [r,g,b].map(x=>parseInt(x).toString(16).padStart(2,'0')).join('');
      }
    };
  });

  document.getElementById('clear').onclick = () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    lastDrawX = lastDrawY = 0;
  };

  window.onresize = () => {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
  };

  init();
</script>
</body>
</html>
