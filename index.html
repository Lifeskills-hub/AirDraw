<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AirDraw - MediaPipe Hands</title>

  <!-- MediaPipe + TensorFlow.js (official, always working) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

  <style>
    body { margin:0; background:#000; overflow:hidden; font-family:sans-serif; }
    #video { width:100vw; height:100vh; object-fit:cover; transform:scaleX(-1); } /* mirror */
    #canvas { position:fixed; top:0; left:0; width:100%; height:100%; transform:scaleX(-1); pointer-events:none; }
    #controls {
      position:fixed; bottom:30px; left:50%; transform:translateX(-50%);
      display:flex; gap:18px; z-index:10;
    }
    button {
      width:70px; height:70px; border-radius:50%; border:none; font-weight:bold; color:white; box-shadow:0 4px 15px rgba(0,0,0,0.5);
    }
    #clear { background:#444; width:120px; border-radius:40px; }
    #status {
      position:fixed; top:20px; left:50%; transform:translateX(-50%);
      color:white; background:rgba(0,0,0,0.5); padding:8px 16px; border-radius:8px; z-index:10;
    }
  </style>
</head>
<body>

<video id="video" autoplay playsinline muted></video>
<canvas id="canvas"></canvas>
<div id="status">Loading MediaPipe Hands...</div>

<div id="controls">
  <button style="background:#fff; color:#000">White</button>
  <button style="background:#ffff00; color:#000">Yellow</button>
  <button style="background:#ff0066">Pink</button>
  <button style="background:#00ffff">Cyan</button>
  <button style="background:#ff6600">Orange</button>
  <button id="clear">CLEAR</button>
</div>

<script>
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const status = document.getElementById('status');
  
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let detector;
  let currentColor = '#ffff00';
  let lastX = null, lastY = null;
  let isDrawing = false;

  // Index finger tip = landmark 8
  const FINGER_TIP_INDEX = 8;

  async function init() {
    status.textContent = "Loading model...";

    await tf.setBackend('webgl').catch(() => tf.setBackend('wasm'));

    const model = handPoseDetection.SupportedModels.MediaPipeHands;
    const detectorConfig = {
      runtime: 'tfjs',
      modelType: 'full',
      maxHands: 1,
      solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands',
    };

    detector = await handPoseDetection.createDetector(model, detectorConfig);
    status.textContent = "Model ready! Starting camera...";

    startCamera();
  }

  async function startCamera() {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: 1280, height: 720 },
      audio: false
    });
    video.srcObject = stream;
    video.play();

    video.onloadedmetadata = () => {
      status.textContent = "Draw in the air with your index finger!";
      requestAnimationFrame(detectHands);
    };
  }

  async function detectHands() {
    if (!detector) return requestAnimationFrame(detectHands);

    const hands = await detector.estimateHands(video, { flipHorizontal: true });

    // Optional: clear previous indicator dots (we keep drawings)
    // ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (hands.length > 0) {
      const landmarks = hands[0].keypoints;
      const tip = landmarks[FINGER_TIP_INDEX];

      const x = tip.x;
      const y = tip.y;

      // Draw colorful fingertip cursor
      ctx.fillStyle = currentColor;
      ctx.shadowBlur = 20;
      ctx.shadowColor = currentColor;
      ctx.beginPath();
      ctx.arc(x, y, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Draw line when moving
      if (isDrawing && lastX !== null && lastY !== null) {
        ctx.lineWidth = 16;
        ctx.lineCap = 'round';
        ctx.strokeStyle = currentColor;
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      lastX = x;
      lastY = y;
      isDrawing = true;
    } else {
      isDrawing = false;
      lastX = null;
      lastY = null;
    }

    requestAnimationFrame(detectHands);
  }

  // Color buttons
  document.querySelectorAll('#controls button:not(#clear)').forEach(btn => {
    btn.onclick = () => {
      currentColor = btn.style.backgroundColor;
      // Convert rgb() to hex if needed
      if (currentColor.startsWith('rgb')) {
        const rgb = currentColor.match(/\d+/g);
        currentColor = '#' + rgb.map(x => parseInt(x).toString(16).padStart(2,'0')).join('');
      }
    };
  });

  // Clear
  document.getElementById('clear').onclick = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    lastX = null;
    lastY = null;
  };

  // Resize handling
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  });

  // Start everything
  init().catch(err => {
    status.textContent = "Error: " + err.message;
    console.error(err);
  });
</script>
</body>
</html>
