<script type="module">
  const videoElement = document.querySelector('.input_video');
  const canvasElement = document.querySelector('.output_canvas');
  const canvasCtx = canvasElement.getContext('2d');
  const scoreElement = document.getElementById('score');

  let currentFacing = 'user';
  let isMirrored = true;
  let currentStream = null;
  let currentColor = 'blue';
  let strokes = [];
  let currentStroke = { points: [], color: currentColor, width: 6 };
  let flies = [];
  let trappedFlies = []; // NEW: Flies that are caught
  let score = 0;

  function updateScore() {
    scoreElement.textContent = score;
  }

  function changeColor(color) {
    currentColor = color;
    if (currentStroke.points.length > 0) currentStroke.color = color;
  }

  function clearCanvas() {
    strokes = [];
    currentStroke = { points: [], color: currentColor, width: 6 };
    flies = [];
    trappedFlies = [];
    score = 0;
    updateScore();
    for (let i = 0; i < 5; i++) spawnFly();
    redraw();
  }

  function redraw() {
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    // Draw completed strokes
    strokes.forEach(stroke => drawStroke(stroke));

    // Draw current stroke
    if (currentStroke.points.length > 1) {
      drawStroke(currentStroke, true);
    }

    // Draw moving flies
    flies.forEach(fly => {
      canvasCtx.font = '30px Arial';
      canvasCtx.fillText('fly', fly.x - 15, fly.y + 10);
    });

    // Draw trapped flies (frozen)
    trappedFlies.forEach(fly => {
      canvasCtx.font = '30px Arial';
      canvasCtx.fillStyle = '#ff4444';
      canvasCtx.fillText('fly', fly.x - 15, fly.y + 10);
    });
  }

  function drawStroke(stroke, isCurrent = false) {
    if (stroke.points.length < 2) return;

    canvasCtx.beginPath();
    canvasCtx.strokeStyle = stroke.color;
    canvasCtx.lineWidth = stroke.width;
    canvasCtx.lineCap = 'round';
    canvasCtx.lineJoin = 'round';

    const points = stroke.points;
    canvasCtx.moveTo(points[0].x, points[0].y);

    for (let i = 1; i < points.length - 1; i++) {
      const xc = (points[i].x + points[i + 1].x) / 2;
      const yc = (points[i].y + points[i + 1].y) / 2;
      canvasCtx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
    }
    if (points.length > 1) {
      const last = points.length - 1;
      canvasCtx.quadraticCurveTo(points[last - 1].x, points[last - 1].y, points[last].x, points[last].y);
    }

    if (isCurrent && currentStroke.points.length > 10) {
      canvasCtx.shadowBlur = 15;
      canvasCtx.shadowColor = stroke.color;
      canvasCtx.stroke();
      canvasCtx.shadowBlur = 0;
    } else {
      canvasCtx.stroke();
    }
  }

  async function startCamera(facing) {
    if (currentStream) currentStream.getTracks().forEach(t => t.stop());
    const constraints = { video: { facingMode: facing, width: { ideal: 1280 }, height: { ideal: 720 } } };
    try {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      currentStream = stream;
      videoElement.srcObject = stream;
      videoElement.play();

      videoElement.onloadedmetadata = () => {
        setupCanvas();
        spawnInitialFlies();
        animate();
      };
    } catch (err) {
      console.error("Camera error:", err);
      alert("Camera access denied.");
    }
  }

  function setupCanvas() {
    canvasElement.width = videoElement.videoWidth;
    canvasElement.height = videoElement.videoHeight;
  }

  function toggleCamera() {
    currentFacing = currentFacing === 'user' ? 'environment' : 'user';
    startCamera(currentFacing);
  }

  function toggleMirror() {
    isMirrored = !isMirrored;
    videoElement.classList.toggle('mirrored', isMirrored);
    canvasElement.classList.toggle('mirrored', isMirrored);
  }

  function spawnFly() {
    const margin = 60;
    flies.push({
      x: margin + Math.random() * (canvasElement.width - 2 * margin),
      y: margin + Math.random() * (canvasElement.height - 2 * margin),
      vx: (Math.random() - 0.5) * 3,
      vy: (Math.random() - 0.5) * 3
    });
  }

  function spawnInitialFlies() {
    flies = [];
    trappedFlies = [];
    for (let i = 0; i < 5; i++) spawnFly();
  }

  function animate() {
    updateFlies();
    redraw();
    requestAnimationFrame(animate);
  }

  function updateFlies() {
    const w = canvasElement.width, h = canvasElement.height;
    flies.forEach(fly => {
      fly.x += fly.vx;
      fly.y += fly.vy;
      if (fly.x < 40 || fly.x > w - 40) fly.vx *= -1;
      if (fly.y < 40 || fly.y > h - 40) fly.vy *= -1;
      fly.x = Math.max(40, Math.min(w - 40, fly.x));
      fly.y = Math.max(40, Math.min(h - 40, fly.y));
    });
  }

  function onResults(results) {
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

    const landmarks = results.multiHandLandmarks[0];
    const indexTip = landmarks[8];
    const thumbTip = landmarks[4];

    const ix = (isMirrored ? 1 - indexTip.x : indexTip.x) * canvasElement.width;
    const iy = indexTip.y * canvasElement.height;

    // Always draw with index finger (open or closed hand)
    const last = currentStroke.points[currentStroke.points.length - 1];
    const distToLast = last ? Math.hypot(ix - last.x, iy - last.y) : Infinity;

    if (currentStroke.points.length === 0 || distToLast > 10) {
      currentStroke.points.push({ x: ix, y: iy });
    }

    // Auto-detect closed loop (no pinch needed!)
    if (currentStroke.points.length > 25) {
      const first = currentStroke.points[0];
      const last = currentStroke.points[currentStroke.points.length - 1];
      const closeDist = Math.hypot(first.x - last.x, first.y - last.y);

      if (closeDist < 70) {
        // Closed path â†’ create Path2D and check flies
        const path = new Path2D();
        path.moveTo(first.x, first.y);
        currentStroke.points.slice(1).forEach(p => path.lineTo(p.x, p.y));
        path.closePath();

        let caught = 0;
        flies = flies.filter(fly => {
          if (canvasCtx.isPointInPath(path, fly.x, fly.y)) {
            trappedFlies.push({ x: fly.x, y: fly.y }); // Freeze position
            caught++;
            return false;
          }
          return true;
        });

        if (caught > 0) {
          score += caught * 10;
          updateScore();
        }

        // Reset current stroke (circle disappears)
        currentStroke = { points: [], color: currentColor, width: 6 };
      }
    }

    // Visual feedback
    canvasCtx.beginPath();
    canvasCtx.arc(ix, iy, 14, 0, 2 * Math.PI);
    canvasCtx.fillStyle = '#00ff00';
    canvasCtx.fill();
    canvasCtx.strokeStyle = 'white';
    canvasCtx.lineWidth = 2;
    canvasCtx.stroke();
  }

  const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
  });

  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
  });

  hands.onResults(onResults);

  // Start
  startCamera(currentFacing);
  videoElement.classList.toggle('mirrored', isMirrored);
  canvasElement.classList.toggle('mirrored', isMirrored);

  window.addEventListener('resize', () => {
    if (videoElement.videoWidth > 0) setupCanvas();
  });
</script>
